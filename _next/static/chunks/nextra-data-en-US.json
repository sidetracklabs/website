{"/blog":{"title":"Blog","data":{}},"/blog/announcing-sidetrack":{"title":"Announcing Sidetrack","data":{"":"Sidetrack is a new way to manage background jobs in your TypeScript backend. It's meant to a database-backed alternative to Redis-backed job queues, and a TypeScript-first alternative compared to other database-backed job queues. We're currently in the early stages of development, but we're excited to share our progress with you.Please give it a try and let us know what you think! We're excited to get feedback and suggestions from the community.Hop into our introduction to get started!"}},"/examples/transactional-job-insertion":{"title":"Transactional Job Insertion","data":{"insert-a-job-within-a-transaction#Insert a job within a transaction":"One huge advantage of being a database-backed library is that we can insert jobs transactionally!\nThis means that if you are in the middle of a transaction and your transaction fails, your job will be rolled back.For example, say your application logic wants to send a email once a user is created. Here's a Prisma example to insert a job transactionally with Sidetrack's usePrisma function:\n// @noErrors\nimport { PrismaClient } from \"@prisma/client\";\nimport { Sidetrack } from \"sidetrack\";\nimport { usePrisma } from \"@sidetrack/client-prisma\";\nconst prisma = new PrismaClient();\nconst sidetrack = new Sidetrack<{\n  userOnboarding: { email: string };\n}>({\n  databaseOptions: {\n    connectionString: process.env[\"DATABASE_URL\"]!,\n  },\n  queues: {\n    userOnboarding: {\n      handler: async (job) => {\n        console.log(`Welcome ${job.payload.email}`);\n      },\n    },\n  },\n});\n// In this transaction, we're creating both the user and background job\nprisma.$transaction(async (prismaTx) => {\n  const user = await prismaTx.user.create(/* create your user */);\n  return sidetrack.insertJob(\n    \"userOnboarding\",\n    {\n      email: user.email,\n    },\n    { dbClient: usePrisma(prismaTx) },\n  );\n});\n// if you run other application code which fails, the entire transaction will rollback\n// and neither the job nor user will be inserted!\nprisma.$transaction(async (prismaTx) => {\n  const user = await prismaTx.user.create(/* create your user */);\n  await sidetrack.insertJob(\n    \"userOnboarding\",\n    {\n      email: user.email,\n    },\n    { dbClient: usePrisma(prismaTx) },\n  );\n  throw new Error(\"Something went wrong\");\n});"}},"/guides/configuring-queues":{"title":"Configuring Queues","data":{"":"When specifying a queue, you can optionally pass an options object to customize the queue's behavior.\nThere's currently 1 option you can customize:\nmaxAttempts - Default is 1. Increasing this means your job will be retried until currentAttempt <= maxAttempts.","maxattempts#maxAttempts":"By increasing the maxAttempts for a job, you are allowing the job to be retried in the future. All jobs have a default maxAttempts of 1, so if you want a job to run at most 5 times before being marked as failed, you can set maxAttempts to 5.\nimport { Sidetrack } from \"sidetrack\";\nconst sidetrack = new Sidetrack<{\n  userOnboarding: { email: string };\n}>({\n  databaseOptions: {\n    connectionString: process.env[\"DATABASE_URL\"]!,\n  },\n  queues: {\n    userOnboarding: {\n      handler: async (job) => {\n        throw new Error(\"intentionally failing job\");\n      },\n      options: {\n        maxAttempts: 5,\n        // ^?\n      },\n    },\n  },\n});\nsidetrack.start();\nsidetrack.insertJob(\"userOnboarding\", { email: \"a@example.com\" });\nThis job will fail on the first run then move to retrying status since its currentAttempt (1) is less than 5. After 5 attempts, the job will transition to a status of failed."}},"/guides/custom-db-client":{"title":"Custom database clients","data":{"included-clients#Included clients":"We have support for two clients:\npg (included with sidetrack)\nprisma (install @sidetrack/client-prisma)\nThe pg client can be used as follows:\nimport { usePg, Sidetrack } from \"sidetrack\";\nimport { Pool } from \"pg\";\n// You can also use a pg.Client instead of a pg.Pool\nconst pool = new Pool();\nconst sidetrack = new Sidetrack<{\n  userOnboarding: { email: string };\n}>({\n  databaseOptions: {\n    connectionString: process.env[\"DATABASE_URL\"]!,\n  },\n  queues: {\n    userOnboarding: {\n      handler: async (job) => {\n        console.log(`Welcome ${job.payload.email}`);\n      },\n    },\n  },\n  // This will apply to all methods available on sidetrack\n  dbClient: usePg(pool),\n});\n// You can also override the connection per method\nsidetrack.insertJob(\n  \"userOnboarding\",\n  { email: \"hello@example.com\" },\n  {\n    dbClient: usePg(pool),\n  },\n);\nSimilarly, the @sidetrack/client-prisma package exposes a usePrisma function that can be used to create a client that works with prisma. You can find the documentation for it here.\nWith this custom client, you can now run most of the functions that are\navailable within the Sidetrack class in a transaction. Pass in a client\nthat's running within a transaction, and it \"just works\"!","creating-your-own-client#Creating your own client":"Sidetrack is designed to support working with your database client library of choice, as long as it works with the databases that are supported by sidetrack. To do this, you need to implement the SidetrackDatabaseClient interface, which you can find here. It currently has one method called execute.For example, you can find the implementation of the usePg function here"}},"/guides/errors-and-logging":{"title":"Error and Logging","data":{"":"Whenever Sidetrack encounters an unhandled exception while running your job, the error and stack trace will be appended to the errors field for that job, and the job will be marked as failed (or retrying if more attempts are available).While you can always refer to the errors field on the job to see what went wrong, you should consider adding logs.\n// @noErrors\nimport { Sidetrack, SidetrackJobWithPayload } from \"sidetrack\";\nconst onboardUser = async (job: SidetrackJobWithPayload<{ email: string }>) => {\n  try {\n    // do something\n  } catch (error) {\n    logger.error(`Job ${job.id} failed`, error);\n    throw error;\n  }\n};\nconst sidetrack = new Sidetrack<{\n  userOnboarding: { email: string };\n}>({\n  databaseOptions: {\n    connectionString: process.env[\"DATABASE_URL\"]!,\n  },\n  queues: {\n    userOnboarding: {\n      handler: onboardUser,\n    },\n  },\n});"}},"/guides/running-migrations":{"title":"Running migrations","data":{"":"Migrations will automatically be run when you call sidetrack.start().\nThe migrations creates a sidetrack_job table in your database, under the sidetrack schema.If you want to manually run the migrations, call runMigrations with your database connection string.\n// @noErrors\nimport { runMigrations } from \"sidetrack\";\nawait runMigrations(process.env[\"DATABASE_URL\"]!);"}},"/guides/testing-sidetrack":{"title":"Testing Sidetrack","data":{"":"Sidetrack provides multiple test utilities function under the SidetrackTest class.The SidetrackTest class extends all the functions under Sidetrack, but also exposes these helpful utils:\nrunJob\nrunJobs\nlistJobs\nlistJobStatuses\nHere's some common scenarios when testing your background jobs.","running-a-job#Running a job":"In your tests, if you don't run sidetrack.start(), then Sidetrack won't poll your database for new jobs.\nYou can manually run a job with the runJob function.\nimport { SidetrackTest } from \"sidetrack\";\nimport { expect, it } from \"vitest\";\nit(\"job runs\", async () => {\n  const sidetrack = new SidetrackTest<{\n    userOnboarding: { email: string };\n  }>({\n    databaseOptions: {\n      connectionString: process.env[\"DATABASE_URL\"]!,\n    },\n    queues: {\n      userOnboarding: {\n        handler: async (job) => {\n          console.log(\"ran job\");\n        },\n      },\n    },\n  });\n  const job = await sidetrack.insertJob(\"userOnboarding\", {\n    email: \"a@example.com\",\n  });\n  // this job stays in scheduled and won't be run because we haven't run sidetrack.start()\n  expect((await sidetrack.getJob(job.id)).status).toBe(\"scheduled\");\n  // You decide when to run the job\n  await sidetrack.runJob(job.id);\n  expect((await sidetrack.getJob(job.id)).status).toBe(\"completed\");\n});","running-jobs-in-a-queue#Running jobs in a queue":"While runJob only allows you to run a single job, often you may want to run all the jobs on a queue.\n// You can run jobs on a single queue\nawait sidetrack.runJobs({ queue: \"userOnboarding\" });\nBy default, runJobs runs jobs that are scheduled in the past or present. If you want to include future jobs you may pass an option for {includeFutureJobs: true}\n// Will run all jobs on this queue, including ones with scheduledAt in the future\nawait sidetrack.runJobs(\n  { queue: \"userOnboarding\" },\n  { includeFutureJobs: true },\n);","listing-jobs#Listing jobs":"You may want to assert that certain jobs exist on a queue(s).\nlistJob accepts a single queue or list of queues, and returns a list of jobs.\nawait sidetrack.insert(\"userOnboarding\", { email: \"a@example.com\" });\nawait sidetrack.insert(\"userOnboarding\", { email: \"b@example.com\" });\n// You can run jobs on a single queue\nconst jobs = await sidetrack.listJobs({ queue: \"userOnboarding\" });\nexpect(jobs.length).toBe(2);","listing-job-statuses#Listing job statuses":"listJobStatuses provides a convenient way to know the breakdown of all the jobs and their statuses.\nconst job1 = await sidetrack.insert(\"userOnboarding\", {\n  email: \"a@example.com\",\n});\nawait sidetrack.insert(\"userOnboarding\", { email: \"b@example.com\" });\nawait sidetrack.runJob(job1.id);\n// since we only ran job 1\n// we should expect 1 job to be completed, 1 job to be in scheduled\nconst jobs = await sidetrack.listJobsStatuses(\"userOnboarding\");\nexpect(jobs).toBeObject({ scheduled: 1, completed: 1 });"}},"/guides/using-effect":{"title":"Using Effect","data":{"using-effect-ts#Using Effect-TS?":"If you are using Effect-TS, Sidetrack exports an Effect-based API as well.Sidetrack is written with Effect, which means that you can use the Effect API directly if you prefer.\n// @noErrors\nimport * as Effect from \"effect/Effect\";\nimport { createSidetrackServiceTag, makeLayer } from \"sidetrack/effect\";\ntype Queues = {\n  userOnboarding: { email: string };\n};\nconst SidetrackService = createSidetrackServiceTag<Queues>();\nconst sidetrackLayer = makeLayer<Queues>({\n  databaseOptions: {\n    connectionString: process.env[\"DATABASE_URL\"]!,\n  },\n  queues: {\n    userOnboarding: {\n      handler: async (job) => {\n        console.log(`Welcome ${job.payload.email}`);\n      },\n    },\n  },\n});\nconst program = Effect.runPromise(\n  Effect.flatMap(SidetrackService, (sidetrack) =>\n    sidetrack.insertJob(\"userOnboarding\", { email: \"hello@example.com\" }),\n  ).pipe(Effect.provide(sidetrackLayer)),\n);\nIf the sidetrack/effect import doesn't work, you will need to use\nimport { SidetrackEffect } from \"sidetrack\";\nand access the methods on that\nexport (e.g. SidetrackEffect.makeLayer). Certain TypeScript configurations\ndon't allow for that import to work correctly.\nYou can find the remaining reference documentation for the Effect docs here. The functions are similar to the ones in the class-based API, but they return Effects instead of Promises, with some error handling. Over time, the Effect API might be expanded to include more features. Please open an issue if you have any requests for how we can make the API more ergonomic or \"Effectful.\"The test utils mentioned in the Testing Sidetrack section can also be found under the testUtils key in the sidetrack service. For example, you can do sidetrack.testUtils.runJob in the example above."}},"/guides/working-with-types":{"title":"Working with Types","data":{"":"Typing the queues and handlers will help prevent you from misusing Sidetrack, like inserting a job on a nonexistent queue, or inserting a job with an invalid payload. Following the types will improve your developer experience.To get started, pass in the type for Sidetrack's constructor. This type is an object with keys that match your queue names, and values that are the type of the payload for that queue. For example, if you have a queue called userOnboarding, and the payload is an object with an email property, you can type your queues like this:\ntype QueueNamesAndPayloads = {\n  userOnboarding: { email: string };\n};\nThe type of your payload must only use JSON serializable values, since the job payload will be persisted in the DB as JSONB.Here is the full example:\nimport { Sidetrack } from \"sidetrack\";\ntype QueueNamesAndPayloads = {\n  userOnboarding: { email: string };\n};\nconst sidetrack = new Sidetrack<QueueNamesAndPayloads>({\n  databaseOptions: {\n    connectionString: process.env[\"DATABASE_URL\"]!,\n  },\n  queues: {\n    userOnboarding: {\n      handler: async (job) => {\n        console.log(`Welcome ${job.payload.email}`);\n      },\n    },\n  },\n});\n// @include: main\nNotice how the handler function receives a job. This job contains a payload key which will be typed to match your payload types above. The job also contains other fields you can use in your handler function (e.g. the job's id, scheduledAt, status, currentAttempt, etc.)","avoiding-errors#Avoiding errors":"You can insert a job on only the userOnboarding queue. Notice the type error if I try inserting on a queue that doesn't exist.\n// @include: main\n// ---cut---\n// @errors: 2345\nsidetrack.insertJob(\"reports\", { email: \"a@example.com\" });\nTypes also prevent you from inserting a job with incorrect payload. Notice I must pass a email of type string.\n// @include: main\n// ---cut---\n// @errors: 2353\nsidetrack.insertJob(\"userOnboarding\", { phone: \"11111111111\" });","reusable-types#Reusable Types":"Sidetrack exports most of the types it uses internally, so you can easily type your handlers and queues. For example, if you have a queue called userOnboarding, you can type your handler like this:\nimport { Sidetrack, SidetrackQueues } from \"sidetrack\";\ntype QueueNamesAndPayloads = {\n  userOnboarding: { email: string };\n};\nconst queues: SidetrackQueues<QueueNamesAndPayloads> = {\n  userOnboarding: {\n    handler: async (job) => {\n      console.log(`Welcome ${job.payload.email}`);\n    },\n  },\n};\nconst sidetrack = new Sidetrack<QueueNamesAndPayloads>({\n  databaseOptions: {\n    connectionString: process.env[\"DATABASE_URL\"]!,\n  },\n  queues,\n});\nNotice how the SidetrackQueues helper type lets you type your queues before you pass them in to the constructor, so you can also re-use them."}},"/":{"title":"Welcome to Sidetrack","data":{"":"Sidetrack is a background job processing library in Typescript, backed by Postgres.These docs cover the basics of Sidetrack. If you're looking for a more in-depth reference, check out the Reference Docs.\nQuickstart"}},"/quickstart":{"title":"Quickstart","data":{"":"In this tutorial, you'll learn how to add Sidetrack to your project and run your first job.\nInstall using your package manager of choice.\nnpm install sidetrack\nimport { Sidetrack } from \"sidetrack\";\nconst sidetrack = new Sidetrack<{\n  userOnboarding: { email: string };\n}>({\n  databaseOptions: {\n    connectionString: process.env[\"DATABASE_URL\"]!,\n  },\n  queues: {\n    userOnboarding: {\n      handler: async (job) => {\n        console.log(`Welcome ${job.payload.email}!`);\n      },\n    },\n  },\n});\nImport it into your project, and initialize Sidetrack by defining your queues.\nPlease note that we only support PostgreSQL at the moment.\n// @include: main\nsidetrack.start(); // starts listening for new jobs in your DB\nNotice how you pass in the types for your queues, specifying your queueName as the key (userOnboarding), and the value being the type for your job's payload ({email: string}).To insert a job, use the insertJob function to specify the queue and the job payload.\n// @include: main\n// ---cut---\nsidetrack.insertJob(\"userOnboarding\", { email: \"a@example.com\" });\nOnce the job is inserted, Sidetrack will pick it up and run it. You should see a log in your terminal!\nWelcome a@example.com!\nYou are ready to continue your Sidetrack journey! Good luck (and don't get sidetracked)!"}},"/why-sidetrack":{"title":"Why Sidetrack","data":{"motivation#Motivation":"We've used database-backed background job libraries in production for years, and we've found that they are a great choice for a lot of applications.After working on a handful of applications, we felt there was room for improvement with the libraries in the TypeScript/JavaScript ecosystem for working with background jobs. The most popular job processing libraries in the ecosystem use Redis, which is a great tool, but we wanted to use a database that we were already using in our applications. Additionally, databases allow for transactional guarantees, so we can avoid inserting jobs into the queue if the transaction fails. We primarily wanted to be able to use TypeScript to work with our background jobs and have a great developer experience.Our focus is on relational databases, namely PostgreSQL, but we are open to supporting other relational databases in the future.This is the first open-source project we've worked on together, and we're excited to share it with you!"}}}