{"/blog":{"title":"Blog","data":{"":""}},"/blog/announcing-sidetrack":{"title":"Announcing Sidetrack","data":{"":"Sidetrack is a new way to manage background jobs in your TypeScript backend. It's meant to a database-backed alternative to Redis-backed job queues, and a TypeScript-first alternative compared to other database-backed job queues. We're currently in the early stages of development, but we're excited to share our progress with you.Please give it a try and let us know what you think! We're excited to get feedback and suggestions from the community.Hop into our introduction to get started!"}},"/examples/transactional-job-insertion":{"title":"Transactional Job Insertion","data":{"":"","insert-a-job-within-a-transaction#Insert a job within a transaction":"One huge advantage of being a database-backed library is that we can insert jobs transactionally! This means that if you are in the middle of a transaction and your transaction fails, you can roll back.The following is an example of how to insert a job transactionally with the sidetrack Prisma client wrapper:"}},"/guides/configuring-queues":{"title":"Configuring Queues","data":{"":"When specifying a queue, you can optionally pass a options object to customize the queue's behavior.\nThere's currently only 1 option you can customize:\nmaxAttempts - Default is 1. Increasing this means your job will be retried until currentAttempt <= maxAttempts.","maxattempts#maxAttempts":"By increasing the maxAttempts for a job, you are allowing the job to be retried in the future. All jobs have a default maxAttempts of 1, so if you want a job to run at most 5 times before being marked as failed, you can set maxAttempts to 5.This job will fail on the first run, and move to retrying status since its currentAttempt (1) is less than 5. After 5 attempts, the job will transition to a status of failed.","uniqueon#uniqueOn":"uniqueOn - Used to enforce uniqueness before inserting a job on the queue.\nbackoff - The strategy used for retrying jobs. Default is exponential backoff inspired by Resque.\n\nYou can enforce job uniqueness in the following ways:\npayloadKeys, scheduledAt, status"}},"/guides/custom-db-client":{"title":"Custom database clients","data":{"":"","included-clients#Included clients":"We have support for two clients out of the box:\npg\nprisma\n\nThe pg client can be imported sidetrack package and used as follows:Similarly, the @sidetrack/client-prisma package exposes a makePrismaSidetrackClient function that can be used to create a client that works with prisma. You can find the documentation for it here.\nWith this custom client, you can now run most of the functions that are\navailable within the Sidetrack class in a transaction. Pass in a client\nthat's running within a transaction, and it \"just works\"!","creating-your-own-client#Creating your own client":"Sidetrack is designed to support working with your database library of choice, as long as it works with the databases that are supported by sidetrack. To do this, you need to implement the SidetrackDatabaseClient interface, which you can find here. It currently has one method called execute.For example, you can find the implementation of the makePgSidetrackClient function here"}},"/guides/errors-and-logging":{"title":"Error and Logging","data":{"":"Whenever Sidetrack encounters an unhandled exception while running your job, the error and stack trace will be appended to the errors field for that job, and the job will be marked as failed (or retrying if more attempts are available).While you can always refer to the errors field on the job to see what went wrong, you should consider adding logs."}},"/guides/running-migrations":{"title":"Running migrations","data":{"":"Migrations will automatically be run when you call sidetrack.start().\nThe migrations creates a sidetrack_job table in your database, under the sidetrack schema.If you want to manually run the migrations, call runMigrations with your database connection string."}},"/guides/testing-sidetrack":{"title":"Testing Sidetrack","data":{"":"Sidetrack provides multiple test utilities function under the SidetrackTest class.The SidetrackTest class extends all the functions under Sidetrack, but also exposes these helpful utils:\nrunJob\nrunJobs\nlistJobs\nlistJobStatuses\n\nHere's some common scenarios when testing your background jobs.","running-a-job#Running a job":"In your tests, if you don't run sidetrack.start(), then Sidetrack won't poll your database for new jobs.\nYou can manually run a job with the runJob function.","running-jobs-in-a-queue#Running jobs in a queue":"While runJob only allows you to run a single job, often you may want to run all the jobs on a queue.By default, runJobs runs jobs that are scheduled in the past or present. If you want to include future jobs you may pass an option for {includeFutureJobs: true}","listing-jobs#Listing jobs":"You may want to assert that certain jobs exist on a queue(s).\nlistJob accepts a single queue or list of queues, and returns a list of jobs.","listing-job-statuses#Listing job statuses":"listJobStatuses provides a convenient way to know the breakdown of all the jobs and their statuses."}},"/guides/using-effect":{"title":"Using Effect","data":{"":"","using-effect-ts#Using Effect-TS?":"If you are using Effect-TS, Sidetrack exports an Effect-based API as well.\nIf you are using moduleResolution: node in your TSConfig, you will need to\nuse import {SidetrackEffect} from \"sidetrack\" and access the methods on that\nexport (e.g. SidetrackEffect.makeLayer).\nYou can find the remaining reference documentation for the Effect docs here. The functions are similar to the ones in the class-based API, but they return Effects instead of Promises, with some error handling. Over time, the Effect API might be expanded to include more features. Please open an issue if you have any requests for how we can make the API more ergonomic or \"Effectful.\"The test utils mentioned in the Testing Sidetrack section can also be found under the testUtils key in the sidetrack service. For example, you can do sidetrack.testUtils.runJob in the example above."}},"/guides/working-with-types":{"title":"Working with Types","data":{"":"Typing the queues and handlers will help prevent you from misusing Sidetrack, like inserting a job on a nonexistent queue, or inserting a job with an invalid payload. Following the types will improve your developer experience.To get started, pass in the type for Sidetrack's constructor. This type is an object with keys that match your queue names, and values that are the type of the payload for that queue. For example, if you have a queue called userOnboarding, and the payload is an object with an email property, you can type your queues like this:The type of your payload must only use JSON serializable values, since the job payload will be persisted in the DB as JSONB.Here is the full example:Notice how the handler function receives a job. This job contains a payload key which will be typed to match your payload types above. The job also contains other fields you can use in your handler function (e.g. the job's id, scheduledAt, status, currentAttempt, etc.)","avoiding-errors#Avoiding errors":"You can insert a job on only the userOnboarding queue. Notice the type error if I try inserting on a queue that doesn't exist.Types also prevent you from inserting a job with incorrect payload. Notice I must pass a email of type string.","reusable-types#Reusable Types":"Sidetrack exports most of the types it uses internally, so you can easily type your handlers and queues. For example, if you have a queue called userOnboarding, you can type your handler like this:Notice how the SidetrackQueues helper type lets you type your queues before you pass them in to the constructor, so you can also re-use them."}},"/":{"title":"Welcome to Sidetrack","data":{"":"Sidetrack is a background job processing library in Typescript, backed by your database.These docs cover the basics of Sidetrack. If you're looking for a more in-depth reference, check out the Reference Docs.\n\n\nQuickstart"}},"/quickstart":{"title":"Quickstart","data":{"":"In this tutorial, you'll learn how to add Sidetrack to your project and run your first job.\nInstall using your package manager of choice.\n\n\nImport it into your project, and initialize Sidetrack by defining your queues.\n\n\nPlease note that we only support PostgreSQL at the moment.\nNotice how you pass in the types for your queues, specifying your queueName as the key (userOnboarding), and the value being the type for your job's payload ({email: string}).To insert a job, use the insertJob function to specify the queue and the job payload.Once the job is inserted, Sidetrack will pick it up and run it. You should see a log in your terminal!You are ready to continue your Sidetrack journey! Good luck (and don't get sidetracked)!"}},"/why-sidetrack":{"title":"Why Sidetrack","data":{"":"","motivation#Motivation":"Putting a job queue in a database sometimes gets a bad rap. It's often said that databases are not suited for this, or that they aren't scalable. We've found that a database-backed job queue can get you really far, and it's a great choice for a lot of new applications. We've used database-backed background job libraries in production for years, and have found that many of the recommendations given about additional job processing tools may only be necessary at a certain scale, much larger than your typical app.After working on a handful of applications, we couldn't find a library in the TypeScript/JavaScript ecosystem for working with background jobs that was database-backed and TypeScript-first. The most popular job processing libraries in the ecosystem use Redis, which is a great tool, but we wanted to use a database that we were already using in our applications. We wanted to be able to use TypeScript to define our jobs and have a great developer experience. Additionally, databases allow for transactional guarantees, so we can avoid inserting jobs into the queue if the transaction fails.Our focus is on relational databases, namely PostgreSQL, but we are open to supporting other relational databases in the future. This would make Sidetrack the first database-backed job processing library in the Node.js ecosystem that we know of to support more than one database (i.e. PostgreSQL).We also love using Effect-TS, and had to create internal wrappers around other libraries to make them work with Effect. We wanted to create a library that was built with Effect in mind, and that would allow us to use Effect.This is the first open-source project we've worked on together, and we're excited to share it with you!"}}}